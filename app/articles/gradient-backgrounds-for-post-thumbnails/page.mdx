export const metadata = {
  title: "Gradient Backgrounds for Post Thumbnails",
  description: `I think it's finally time to remove these tacky under construction GIFs and make some changes around here! Check out this article to see how I did it!`,
  date: "Mar 29, 2024",
  authors: ["Anthony Coffey"],
};

When I first created this site, I was creating post thumbnails in Photoshop using
a PSD template that I created. This process was not only time-consuming, but I was also never fully satisfied with the results.

My gut was telling me at the time to pursue a more programmatic approach to creating the design I wanted, but I ignored it.
It's been driving me crazy for weeks now, so lets take a look at how we can create the same design but without images - just code!

### The Problem

My blog templates used to display post thumbnail as a background image. However, this was a problem because I had to manually
create each image. When trying to create content on the fly, it's not very intuitive and can ultimately slow down my workflow.

First, let's take a look at the old code for the `AllArticles` component that displays a grid of post thumbnails. Please note that Tailwind CSS classes have been removed for clarity.

```jsx
import React from "react";
import { getAllArticles } from "utils/getArticles";
import Link from "next/link";
import Image from "next/image";
import ArticleInfo from "./ArticleInfo";

export default async function AllArticles() {
  const articles = await getAllArticles();

  return (
    <div>
      {articles.map((article) => {
        const { metadata } = article;
        const title = String(metadata.title);

        return (
          <Link key={title} href={"/articles/" + article.slug}>
            {metadata.image && (
              <Image
                className="h-66 w-full object-cover"
                src={metadata.image}
                alt={title}
              />
            )}
            <div>
              <ArticleInfo article={article} />
              <h3>{title}</h3>
              <p>{metadata.description}</p>
            </div>
          </Link>
        );
      })}
    </div>
  );
}
```

### The Solution

First, let's replace the code above with an HTML/CSS based approach that will generate background gradients for each post.

The code below will generate a gradient background for each post. I'll explain how it works down below!

```jsx
import React from "react";
import { getAllArticles } from "utils/getArticles";
import Link from "next/link";
import ArticleInfo from "./ArticleInfo";
import generateRandomGradient from "utils/generateRandomGradient";

export default async function AllArticles() {
  const articles = await getAllArticles();

  return (
    <div>
      {articles.map((article) => {
        const { metadata, slug } = article;
        const title = String(metadata.title);
        const gradientStyle = {
          backgroundImage: generateRandomGradient(slug),
          minHeight: "250px",
        };

        return (
          <Link key={title} href={"/articles/" + article.slug}>
            <div style={gradientStyle}>
              <h3 className="post-title">{title}</h3>
            </div>
            <div className="p-2 m-2">
              <ArticleInfo article={article} />
              <p>{metadata.description}</p>
            </div>
          </Link>
        );
      })}
    </div>
  );
}
```

This code generates a random gradient for each post and sets it as the background of the post thumbnail. This will give each post a unique look without having to create a new image for each one.

### How does it work?

The core of our approach is the `generateRandomGradient` function. This function takes a seed value (typically a unique identifier like a slug or title from your data) and uses it to generate a pseudo-random gradient. Here's the function:

```ts
const generateRandomGradient = (seed: string) => {
  const colorPairs: string[][] = [
    ["#00FFFF", "#0000FF"], // Cyan to Blue
    ["#1E90FF", "#32CD32"], // Dodger Blue to Lime Green
    ["#00FF7F", "#8A2BE2"], // Spring Green to Blue Violet
    ["#008080", "#FF4500"], // Teal to Orange Red
    ["#6A5ACD", "#00FF00"], // Slate Blue to Lime
    ["#0000FF", "#FFD700"], // Blue to Gold
    ["#5F9EA0", "#DC143C"], // Cadet Blue to Crimson
    ["#40E0D0", "#FF8C00"], // Turquoise to Dark Orange
  ];

  // Modified hash function to incorporate the position of each character
  const hash = Array.from(seed).reduce(
    (acc, char, index) => acc + char.charCodeAt(0) * (index + 1),
    0,
  );

  const index = hash % colorPairs.length;
  const [color1, color2] = colorPairs[index];

  // Use the hash to generate percentages for the gradient's center position
  const xPercent = hash % 100;
  const yPercent = (hash / 100) % 100;

  return `radial-gradient(circle at ${xPercent}% ${yPercent}%, ${color1}, ${color2})`;
};

export default generateRandomGradient;
```

Here is a quick breakdown of everything that's happening in the `generateRandomGradient` function:

1. **Define color pairs**: The function starts with an array of color pairs. Each pair consists of two colors that will be used to create the gradient. These colors are chosen to be pastel shades that transition smoothly from one to another.

2. **Generate a hash from the seed**: The function uses a custom hash function to convert the validSeed into a numerical value (hash). This is done by iterating over each character in the seed, converting the character to its ASCII code using `charCodeAt(0)`, multiplying it by its position in the string, and adding it to an accumulator. This hash is used to ensure that different seeds produce different gradients.

3. **Select a color pair based on the hash**: The function calculates an index by taking the modulus of the hash with the length of the `colorPairs` array. This ensures that the index is within the bounds of the array. The corresponding color pair is then selected and destructured into color1 and color2.

4. **Generate percentages for the gradient's center position**: The function calculates two percentages based on the hash. These percentages determine the position of the center of the radial gradient. This adds an element of variability to the gradient based on the seed.

5. **Return the CSS radial gradient**: Finally, the function constructs a CSS radial-gradient string using the selected colors and the calculated percentages for the center position. This string can be used in CSS to set the background of an element to the generated gradient.

Overall, this function allows for the generation of a variety of radial gradients based on a seed value, which can be useful for creating dynamic and visually appealing backgrounds in web development. Using this approach, the same gradient is returned for the same seed value, ensuring consistency across multiple uses of the function. Also, in production I've added more color combos and with the hash function, it's unlikely that the same gradient will be generated for different seeds.

### Closing Thoughts

Now, I can create the look and feel I wanted for each post without needing to manually create an image. This will save me time and allow me to focus on creating content rather than designing thumbnails. Now, my next mission is to tackle Open Graph tags to ensure that when I share my posts on social media they look just as good as they do on my site!

Since I've utilized this function in two places, let's go ahead refactor it into a utility function that can be reused across the application. This will help keep our code DRY (Don't Repeat Yourself) and make it easier to maintain in the future.

Thanks for reading! I hope this article has been helpful in showing you how to create unique post thumbnails using CSS gradients. Happy coding!
